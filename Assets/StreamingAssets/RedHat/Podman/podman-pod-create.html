<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>podman-pod-create 1</title>
  <style>
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
</head>
<body>
<h2 id="name">NAME</h2>
<p>podman-pod-create - Create a new pod</p>
<h2 id="synopsis">SYNOPSIS</h2>
<p><strong>podman pod create</strong> [<em>options</em>]
[<em>name</em>]</p>
<h2 id="description">DESCRIPTION</h2>
<p>Creates an empty pod, or unit of multiple containers, and prepares it
to have containers added to it. The pod can be created with a specific
name. If a name is not given a random name is generated. The pod ID is
printed to STDOUT. You can then use <strong>podman create --pod
<code>&lt;pod_id|pod_name&gt;</code> ...</strong> to add containers to
the pod, and <strong>podman pod start
<code>&lt;pod_id|pod_name&gt;</code></strong> to start the pod.</p>
<p>The operator can identify a pod in three ways: UUID long identifier
(&#x201C;f78375b1c487e03c9438c729345e54db9d20cfa2ac1fc3494b6eb60872e74778&#x201D;)
UUID short identifier (&#x201C;f78375b1c487&#x201D;) Name (&#x201C;jonah&#x201D;)</p>
<p>podman generates a UUID for each pod, and if a name is not assigned
to the container with <strong>--name</strong> then a random string name
is generated for it. This name is useful to identify a pod.</p>
<p>Note: resource limit related flags work by setting the limits
explicitly in the pod's cgroup parent for all containers joining the
pod. A container can override the resource limits when joining a pod.
For example, if a pod was created via <strong>podman pod create
--cpus=5</strong>, specifying <strong>podman container create
--pod=<code>&lt;pod_id|pod_name&gt;</code> --cpus=4</strong> causes the
container to use the smaller limit. Also, containers which specify their
own cgroup, such as <strong>--cgroupns=host</strong>, do NOT get the
assigned pod level cgroup resources.</p>
<h2 id="options">OPTIONS</h2>
<h4
id="add-hosthostnamehostname...ip"><strong>--add-host</strong>=<em>hostname[;hostname[;...]]</em>:<em>ip</em></h4>
<p>Add a custom host-to-IP mapping to the pod's <code>/etc/hosts</code>
file.</p>
<p>The option takes one or multiple semicolon-separated hostnames to be
mapped to a single IPv4 or IPv6 address, separated by a colon. It can
also be used to overwrite the IP addresses of hostnames Podman adds to
<code>/etc/hosts</code> by default (also see the <strong>--name</strong>
and <strong>--hostname</strong> options). This option can be specified
multiple times to add additional mappings to <code>/etc/hosts</code>. It
conflicts with the <strong>--no-hosts</strong> option and conflicts with
<em>no_hosts=true</em> in <code>containers.conf</code>.</p>
<p>Instead of an IP address, the special flag <em>host-gateway</em> can
be given. This resolves to an IP address the container can use to
connect to the host. The IP address chosen depends on your network
setup, thus there's no guarantee that Podman can determine the
<em>host-gateway</em> address automatically, which will then cause
Podman to fail with an error message. You can overwrite this IP address
using the <em>host_containers_internal_ip</em> option in
<em>containers.conf</em>.</p>
<p>The <em>host-gateway</em> address is also used by Podman to
automatically add the <code>host.containers.internal</code> and
<code>host.docker.internal</code> hostnames to <code>/etc/hosts</code>.
You can prevent that by either giving the <strong>--no-hosts</strong>
option, or by setting <em>host_containers_internal_ip="none"</em> in
<em>containers.conf</em>. If no <em>host-gateway</em> address was
configured manually and Podman fails to determine the IP address
automatically, Podman will silently skip adding these internal hostnames
to <code>/etc/hosts</code>. If Podman is running in a virtual machine
using <code>podman machine</code> (this includes Mac and Windows hosts),
Podman will silently skip adding the internal hostnames to
<code>/etc/hosts</code>, unless an IP address was configured manually;
the internal hostnames are resolved by the gvproxy DNS resolver
instead.</p>
<p>Podman will use the <code>/etc/hosts</code> file of the host as a
basis by default, i.e. any hostname present in this file will also be
present in the <code>/etc/hosts</code> file of the container. A
different base file can be configured using the <em>base_hosts_file</em>
config in <code>containers.conf</code>.</p>
<p>The /etc/hosts file is shared between all containers in the pod.</p>
<h4
id="blkio-weightweight"><strong>--blkio-weight</strong>=<em>weight</em></h4>
<p>Block IO relative weight. The <em>weight</em> is a value between
<strong>10</strong> and <strong>1000</strong>.</p>
<p>This option is not supported on cgroups V1 rootless systems.</p>
<h4
id="blkio-weight-devicedeviceweight"><strong>--blkio-weight-device</strong>=<em>device:weight</em></h4>
<p>Block IO relative device weight.</p>
<h4
id="cgroup-parentpath"><strong>--cgroup-parent</strong>=<em>path</em></h4>
<p>Path to cgroups under which the cgroup for the pod is created. If the
path is not absolute, the path is considered to be relative to the
cgroups path of the init process. Cgroups are created if they do not
already exist.</p>
<h4 id="cpu-shares--cshares"><strong>--cpu-shares</strong>,
<strong>-c</strong>=<em>shares</em></h4>
<p>CPU shares (relative weight).</p>
<p>By default, all containers get the same proportion of CPU cycles.
This proportion can be modified by changing the container's CPU share
weighting relative to the combined weight of all the running containers.
Default weight is <strong>1024</strong>.</p>
<p>The proportion only applies when CPU-intensive processes are running.
When tasks in one container are idle, other containers can use the
left-over CPU time. The actual amount of CPU time varies depending on
the number of containers running on the system.</p>
<p>For example, consider three containers, one has a cpu-share of 1024
and two others have a cpu-share setting of 512. When processes in all
three containers attempt to use 100% of CPU, the first container
receives 50% of the total CPU time. If a fourth container is added with
a cpu-share of 1024, the first container only gets 33% of the CPU. The
remaining containers receive 16.5%, 16.5% and 33% of the CPU.</p>
<p>On a multi-core system, the shares of CPU time are distributed over
all CPU cores. Even if a container is limited to less than 100% of CPU
time, it can use 100% of each individual CPU core.</p>
<p>For example, consider a system with more than three cores. If the
container <em>C0</em> is started with <strong>--cpu-shares=512</strong>
running one process, and another container <em>C1</em> with
<strong>--cpu-shares=1024</strong> running two processes, this can
result in the following division of CPU shares:</p>
<table>
<thead>
<tr class="header">
<th>PID</th>
<th>container</th>
<th>CPU</th>
<th>CPU share</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>100</td>
<td>C0</td>
<td>0</td>
<td>100% of CPU0</td>
</tr>
<tr class="even">
<td>101</td>
<td>C1</td>
<td>1</td>
<td>100% of CPU1</td>
</tr>
<tr class="odd">
<td>102</td>
<td>C1</td>
<td>2</td>
<td>100% of CPU2</td>
</tr>
</tbody>
</table>
<p>On some systems, changing the resource limits may not be allowed for
non-root users. For more details, see
https://github.com/containers/podman/blob/main/troubleshooting.md#26-running-containers-with-resource-limits-fails-with-a-permissions-error</p>
<p>This option is not supported on cgroups V1 rootless systems.</p>
<h4 id="cpusamount"><strong>--cpus</strong>=<em>amount</em></h4>
<p>Set the total number of CPUs delegated to the pod. Default is 0.000
which indicates that there is no limit on computation power.</p>
<h4
id="cpuset-cpusnumber"><strong>--cpuset-cpus</strong>=<em>number</em></h4>
<p>CPUs in which to allow execution. Can be specified as a
comma-separated list (e.g. <strong>0,1</strong>), as a range (e.g.
<strong>0-3</strong>), or any combination thereof (e.g.
<strong>0-3,7,11-15</strong>).</p>
<p>On some systems, changing the resource limits may not be allowed for
non-root users. For more details, see
https://github.com/containers/podman/blob/main/troubleshooting.md#26-running-containers-with-resource-limits-fails-with-a-permissions-error</p>
<p>This option is not supported on cgroups V1 rootless systems.</p>
<h4
id="cpuset-memsnodes"><strong>--cpuset-mems</strong>=<em>nodes</em></h4>
<p>Memory nodes (MEMs) in which to allow execution (0-3, 0,1). Only
effective on NUMA systems.</p>
<p>If there are four memory nodes on the system (0-3), use
<strong>--cpuset-mems=0,1</strong> then processes in the container only
uses memory from the first two memory nodes.</p>
<p>On some systems, changing the resource limits may not be allowed for
non-root users. For more details, see
https://github.com/containers/podman/blob/main/troubleshooting.md#26-running-containers-with-resource-limits-fails-with-a-permissions-error</p>
<p>This option is not supported on cgroups V1 rootless systems.</p>
<h4
id="devicehost-devicecontainer-devicepermissions"><strong>--device</strong>=<em>host-device[:container-device][:permissions]</em></h4>
<p>Add a host device to the pod. Optional <em>permissions</em> parameter
can be used to specify device permissions by combining
<strong>r</strong> for read, <strong>w</strong> for write, and
<strong>m</strong> for <strong>mknod</strong>(2).</p>
<p>Example: <strong>--device=/dev/sdc:/dev/xvdc:rwm</strong>.</p>
<p>Note: if <em>host-device</em> is a symbolic link then it is resolved
first. The pod only stores the major and minor numbers of the host
device.</p>
<p>Podman may load kernel modules required for using the specified
device. The devices that Podman loads modules for when necessary are:
/dev/fuse.</p>
<p>In rootless mode, the new device is bind mounted in the container
from the host rather than Podman creating it within the container space.
Because the bind mount retains its SELinux label on SELinux systems, the
container can get permission denied when accessing the mounted device.
Modify SELinux settings to allow containers to use all device labels via
the following command:</p>
<p>$ sudo setsebool -P container_use_devices=true</p>
<p>Note: the pod implements devices by storing the initial configuration
passed by the user and recreating the device on each container added to
the pod.</p>
<h4
id="device-read-bpspathrate"><strong>--device-read-bps</strong>=<em>path:rate</em></h4>
<p>Limit read rate (in bytes per second) from a device (e.g.
<strong>--device-read-bps=/dev/sda:1mb</strong>).</p>
<p>On some systems, changing the resource limits may not be allowed for
non-root users. For more details, see
https://github.com/containers/podman/blob/main/troubleshooting.md#26-running-containers-with-resource-limits-fails-with-a-permissions-error</p>
<p>This option is not supported on cgroups V1 rootless systems.</p>
<h4
id="device-write-bpspathrate"><strong>--device-write-bps</strong>=<em>path:rate</em></h4>
<p>Limit write rate (in bytes per second) to a device (e.g.
<strong>--device-write-bps=/dev/sda:1mb</strong>).</p>
<p>On some systems, changing the resource limits may not be allowed for
non-root users. For more details, see
https://github.com/containers/podman/blob/main/troubleshooting.md#26-running-containers-with-resource-limits-fails-with-a-permissions-error</p>
<p>This option is not supported on cgroups V1 rootless systems.</p>
<h4 id="dnsipaddr"><strong>--dns</strong>=<em>ipaddr</em></h4>
<p>Set custom DNS servers in the /etc/resolv.conf file that is shared
between all containers in the pod. A special option, "none" is allowed
which disables creation of /etc/resolv.conf for the pod.</p>
<h4
id="dns-optionoption"><strong>--dns-option</strong>=<em>option</em></h4>
<p>Set custom DNS options in the /etc/resolv.conf file that is shared
between all containers in the pod.</p>
<h4
id="dns-searchdomain"><strong>--dns-search</strong>=<em>domain</em></h4>
<p>Set custom DNS search domains in the /etc/resolv.conf file that is
shared between all containers in the pod.</p>
<h4
id="exit-policycontinue-stop"><strong>--exit-policy</strong>=<strong>continue</strong>
| <em>stop</em></h4>
<p>Set the exit policy of the pod when the last container exits.
Supported policies are:</p>
<table>
<colgroup>
<col style="width: 12%" />
<col style="width: 87%" />
</colgroup>
<thead>
<tr class="header">
<th>Exit Policy</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><em>continue</em></td>
<td>The pod continues running, by keeping its infra container alive,
when the last container exits. Used by default.</td>
</tr>
<tr class="even">
<td><em>stop</em></td>
<td>The pod (including its infra container) is stopped when the last
container exits. Used in <code>kube play</code> and quadlets.</td>
</tr>
</tbody>
</table>
<h4
id="gidmappod_gidhost_gidamount"><strong>--gidmap</strong>=<em>pod_gid:host_gid:amount</em></h4>
<p>GID map for the user namespace. Using this flag runs all containers
in the pod with user namespace enabled. It conflicts with the
<strong>--userns</strong> and <strong>--subgidname</strong> flags.</p>
<h4 id="gpusentry"><strong>--gpus</strong>=<em>ENTRY</em></h4>
<p>GPU devices to add to the container ('all' to pass all GPUs)
Currently only Nvidia devices are supported.</p>
<h4 id="help--h"><strong>--help</strong>, <strong>-h</strong></h4>
<p>Print usage statement.</p>
<h4 id="hostnamename"><strong>--hostname</strong>=<em>name</em></h4>
<p>Set the pod's hostname inside all containers.</p>
<p>The given hostname is also added to the <code>/etc/hosts</code> file
using the container's primary IP address (also see the
<strong>--add-host</strong> option).</p>
<h4
id="hosts-filepath-none-image"><strong>--hosts-file</strong>=<em>path</em>
| <em>none</em> | <em>image</em></h4>
<p>Base file to create the <code>/etc/hosts</code> file inside the
container. This must either be an absolute path to a file on the host
system, or one of the following special flags: "" Follow the
<code>base_hosts_file</code> configuration in <em>containers.conf</em>
(the default) <code>none</code> Do not use a base file (i.e. start with
an empty file) <code>image</code> Use the container image's
<code>/etc/hosts</code> file as base file</p>
<h4 id="infra"><strong>--infra</strong></h4>
<p>Create an infra container and associate it with the pod. An infra
container is a lightweight container used to coordinate the shared
kernel namespace of a pod. Default: true.</p>
<h4
id="infra-commandcommand"><strong>--infra-command</strong>=<em>command</em></h4>
<p>The command that is run to start the infra container. Default:
"/pause".</p>
<h4
id="infra-conmon-pidfilefile"><strong>--infra-conmon-pidfile</strong>=<em>file</em></h4>
<p>Write the pid of the infra container's <strong>conmon</strong>
process to a file. As <strong>conmon</strong> runs in a separate process
than Podman, this is necessary when using systemd to manage Podman
containers and pods.</p>
<h4
id="infra-imageimage"><strong>--infra-image</strong>=<em>image</em></h4>
<p>The custom image that is used for the infra container. Unless
specified, Podman builds a custom local image which does not require
pulling down an image.</p>
<h4 id="infra-namename"><strong>--infra-name</strong>=<em>name</em></h4>
<p>The name that is used for the pod's infra container.</p>
<h4 id="ipipv4"><strong>--ip</strong>=<em>ipv4</em></h4>
<p>Specify a static IPv4 address for the pod, for example
<strong>10.88.64.128</strong>. This option can only be used if the pod
is joined to only a single network - i.e.,
<strong>--network=network-name</strong> is used at most once - and if
the pod is not joining another container's network namespace via
<strong>--network=container:<em>id</em></strong>. The address must be
within the network's IP address pool (default
<strong>10.88.0.0/16</strong>).</p>
<p>To specify multiple static IP addresses per pod, set multiple
networks using the <strong>--network</strong> option with a static IP
address specified for each using the <code>ip</code> mode for that
option.</p>
<h4 id="ip6ipv6"><strong>--ip6</strong>=<em>ipv6</em></h4>
<p>Specify a static IPv6 address for the pod, for example
<strong>fd46:db93:aa76:ac37::10</strong>. This option can only be used
if the pod is joined to only a single network - i.e.,
<strong>--network=network-name</strong> is used at most once - and if
the pod is not joining another container's network namespace via
<strong>--network=container:<em>id</em></strong>. The address must be
within the network's IPv6 address pool.</p>
<p>To specify multiple static IPv6 addresses per pod, set multiple
networks using the <strong>--network</strong> option with a static IPv6
address specified for each using the <code>ip6</code> mode for that
option.</p>
<h4 id="label--lkeyvalue"><strong>--label</strong>,
<strong>-l</strong>=<em>key=value</em></h4>
<p>Add metadata to a pod.</p>
<h4 id="label-filefile"><strong>--label-file</strong>=<em>file</em></h4>
<p>Read in a line-delimited file of labels.</p>
<h4
id="mac-addressaddress"><strong>--mac-address</strong>=<em>address</em></h4>
<p>Pod network interface MAC address (e.g. 92:d0:c6:0a:29:33) This
option can only be used if the pod is joined to only a single network -
i.e., <strong>--network=<em>network-name</em></strong> is used at most
once - and if the pod is not joining another container's network
namespace via <strong>--network=container:<em>id</em></strong>.</p>
<p>Remember that the MAC address in an Ethernet network must be unique.
The IPv6 link-local address is based on the device's MAC address
according to RFC4862.</p>
<p>To specify multiple static MAC addresses per pod, set multiple
networks using the <strong>--network</strong> option with a static MAC
address specified for each using the <code>mac</code> mode for that
option.</p>
<h4 id="memory--mnumberunit"><strong>--memory</strong>,
<strong>-m</strong>=<em>number[unit]</em></h4>
<p>Memory limit. A <em>unit</em> can be <strong>b</strong> (bytes),
<strong>k</strong> (kibibytes), <strong>m</strong> (mebibytes), or
<strong>g</strong> (gibibytes).</p>
<p>Allows the memory available to a container to be constrained. If the
host supports swap memory, then the <strong>-m</strong> memory setting
can be larger than physical RAM. If a limit of 0 is specified (not using
<strong>-m</strong>), the container's memory is not limited. The actual
limit may be rounded up to a multiple of the operating system's page
size (the value is very large, that's millions of trillions).</p>
<p>This option is not supported on cgroups V1 rootless systems.</p>
<h4
id="memory-swapnumberunit"><strong>--memory-swap</strong>=<em>number[unit]</em></h4>
<p>A limit value equal to memory plus swap. A <em>unit</em> can be
<strong>b</strong> (bytes), <strong>k</strong> (kibibytes),
<strong>m</strong> (mebibytes), or <strong>g</strong> (gibibytes).</p>
<p>Must be used with the <strong>-m</strong> (<strong>--memory</strong>)
flag. The argument value must be larger than that of <strong>-m</strong>
(<strong>--memory</strong>) By default, it is set to double the value of
<strong>--memory</strong>.</p>
<p>Set <em>number</em> to <strong>-1</strong> to enable unlimited
swap.</p>
<p>This option is not supported on cgroups V1 rootless systems.</p>
<h4 id="name--nname"><strong>--name</strong>,
<strong>-n</strong>=<em>name</em></h4>
<p>Assign a name to the pod.</p>
<h4 id="networkmode---net"><strong>--network</strong>=<em>mode</em>,
<strong>--net</strong></h4>
<p>Set the network mode for the pod.</p>
<p>Valid <em>mode</em> values are:</p>
<ul>
<li><p><strong>bridge[:OPTIONS,...]</strong>: Create a network stack on
the default bridge. This is the default for rootful containers. It is
possible to specify these additional options:</p>
<ul>
<li><strong>alias=</strong>_name_: Add network-scoped alias for the
container.</li>
<li><strong>ip=</strong>_IPv4_: Specify a static IPv4 address for this
container.</li>
<li><strong>ip6=</strong>_IPv6_: Specify a static IPv6 address for this
container.</li>
<li><strong>mac=</strong>_MAC_: Specify a static MAC address for this
container.</li>
<li><strong>interface_name=</strong>_name_: Specify a name for the
created network interface inside the container.</li>
<li><strong>host_interface_name=</strong>_name_: Specify a name for the
created network interface outside the container.</li>
</ul>
<p>Any other options will be passed through to netavark without
validation. This can be useful to pass arguments to netavark
plugins.</p>
<p>For example, to set a static ipv4 address and a static mac address,
use
<code>--network bridge:ip=10.88.0.10,mac=44:33:22:11:00:99</code>.</p></li>
<li><p><em>&lt;network name or
ID&gt;</em><strong>[:OPTIONS,...]</strong>: Connect to a user-defined
network; this is the network name or ID from a network created by
<strong><a href="podman-network-create.html">podman network
create</a></strong>. It is possible to specify the same options
described under the bridge mode above. Use the
<strong>--network</strong> option multiple times to specify additional
networks.<br />
For backwards compatibility it is also possible to specify
comma-separated networks on the first <strong>--network</strong>
argument, however this prevents you from using the options described
under the bridge section above.</p></li>
<li><p><strong>none</strong>: Create a network namespace for the
container but do not configure network interfaces for it, thus the
container has no network connectivity.</p></li>
<li><p><strong>container:</strong>_id_: Reuse another container's
network stack.</p></li>
<li><p><strong>host</strong>: Use the host's network namespace for the
container instead of creating an isolated namespace. Warning: This gives
the container full access to abstract Unix domain sockets and to TCP/UDP
sockets bound to localhost. Since these mechanisms are often used to
prevent access to sensitive system services, isolating them from access
by external entities, use of this option may be considered a security
vulnerability.</p></li>
<li><p><strong>ns:</strong>_path_: Path to a network namespace to
join.</p></li>
<li><p><strong>private</strong>: Create a new namespace for the
container. This uses the <strong>bridge</strong> mode for rootful
containers and <strong>slirp4netns</strong> for rootless ones.</p></li>
<li><p><strong>slirp4netns[:OPTIONS,...]</strong>: use
<strong>slirp4netns</strong>(1) to create a user network stack. It is
possible to specify these additional options, they can also be set with
<code>network_cmd_options</code> in containers.conf:</p>
<ul>
<li><strong>allow_host_loopback=true|false</strong>: Allow slirp4netns
to reach the host loopback IP (default is 10.0.2.2 or the second IP from
slirp4netns cidr subnet when changed, see the cidr option below). The
default is false.</li>
<li><strong>mtu=</strong>_MTU_: Specify the MTU to use for this network.
(Default is <code>65520</code>).</li>
<li><strong>cidr=</strong>_CIDR_: Specify ip range to use for this
network. (Default is <code>10.0.2.0/24</code>).</li>
<li><strong>enable_ipv6=true|false</strong>: Enable IPv6. Default is
true. (Required for <code>outbound_addr6</code>).</li>
<li><strong>outbound_addr=</strong>_INTERFACE_: Specify the outbound
interface slirp binds to (ipv4 traffic only).</li>
<li><strong>outbound_addr=</strong>_IPv4_: Specify the outbound ipv4
address slirp binds to.</li>
<li><strong>outbound_addr6=</strong>_INTERFACE_: Specify the outbound
interface slirp binds to (ipv6 traffic only).</li>
<li><strong>outbound_addr6=</strong>_IPv6_: Specify the outbound ipv6
address slirp binds to.</li>
<li><strong>port_handler=rootlesskit</strong>: Use rootlesskit for port
forwarding. Default.<br />
Note: Rootlesskit changes the source IP address of incoming packets to
an IP address in the container network namespace, usually
<code>10.0.2.100</code>. If the application requires the real source IP
address, e.g. web server logs, use the slirp4netns port handler. The
rootlesskit port handler is also used for rootless containers when
connected to user-defined networks.</li>
<li><strong>port_handler=slirp4netns</strong>: Use the slirp4netns port
forwarding, it is slower than rootlesskit but preserves the correct
source IP address. This port handler cannot be used for user-defined
networks.</li>
</ul></li>
<li><p><strong>pasta[:OPTIONS,...]</strong>: use
<strong>pasta</strong>(1) to create a user-mode networking stack.<br />
This is the default for rootless containers and only supported in
rootless mode.<br />
By default, IPv4 and IPv6 addresses and routes, as well as the pod
interface name, are copied from the host. Port forwarding preserves the
original source IP address. Options described in pasta(1) can be
specified as comma-separated arguments.<br />
In terms of pasta(1) options, <strong>--config-net</strong> is given by
default, in order to configure networking when the container is started,
and <strong>--no-map-gw</strong> is also assumed by default, to avoid
direct access from container to host using the gateway address. The
latter can be overridden by passing <strong>--map-gw</strong> in the
pasta-specific options (despite not being an actual pasta(1)
option).<br />
For better integration with DNS handling, <strong>--dns-forward
169.254.1.1</strong> is passed, and this address is added to
resolv.conf(5) as first resolver. It is possible to pass
<strong>--dns-forward</strong> explicitly in case a different IP address
should be used. To make the <code>host.containers.internal</code>
/etc/hosts entry work and allow connections to the host,
<strong>--map-guest-addr 169.254.1.2</strong> is passed. Again, it can
be set explicitly to choose a different IP address.<br />
Also, <strong>-t none</strong> and <strong>-u none</strong> are passed
if, respectively, no TCP or UDP port forwarding from host to container
is configured (via Podman's <strong>--publish</strong> or by passing the
pasta <strong>-t</strong>/<strong>-u</strong> options directly), to
disable automatic port forwarding based on bound ports. Similarly,
<strong>-T none</strong> and <strong>-U none</strong> are given to
disable the same functionality from container to host.<br />
All options can also be set in <strong><a
href="https://github.com/containers/common/blob/main/docs/containers.conf.5.md">containers.conf(5)</a></strong>;
see the <code>pasta_options</code> key under the network section in that
file.<br />
Some examples:</p>
<ul>
<li><strong>pasta:--map-gw</strong>: Allow the container to directly
reach the host using the gateway address.</li>
<li><strong>pasta:--mtu,1500</strong>: Specify a 1500 bytes MTU for the
<em>tap</em> interface in the container.</li>
<li><strong>pasta:--ipv4-only,-a,10.0.2.0,-n,24,-g,10.0.2.2,--dns-forward,10.0.2.3,-m,1500,--no-ndp,--no-dhcpv6,--no-dhcp</strong>,
equivalent to default slirp4netns(1) options: disable IPv6, assign
<code>10.0.2.0/24</code> to the <code>tap0</code> interface in the
container, with gateway <code>10.0.2.3</code>, enable DNS forwarder
reachable at <code>10.0.2.3</code>, set MTU to 1500 bytes, disable NDP,
DHCPv6 and DHCP support.</li>
<li><strong>pasta:-I,tap0,--ipv4-only,-a,10.0.2.0,-n,24,-g,10.0.2.2,--dns-forward,10.0.2.3,--no-ndp,--no-dhcpv6,--no-dhcp</strong>,
equivalent to default slirp4netns(1) options with Podman overrides: same
as above, but leave the MTU to 65520 bytes</li>
<li><strong>pasta:-t,auto,-u,auto,-T,auto,-U,auto</strong>: enable
automatic port forwarding based on observed bound ports from both host
and container sides</li>
<li><strong>pasta:-T,5201</strong>: enable forwarding of TCP port 5201
from container to host, using the loopback interface instead of the tap
interface for improved performance</li>
</ul></li>
</ul>
<p>Invalid if using <strong>--dns</strong>,
<strong>--dns-option</strong>, or <strong>--dns-search</strong> with
<strong>--network</strong> set to <strong>none</strong> or
<strong>container:</strong>_id_.</p>
<h4
id="network-aliasalias"><strong>--network-alias</strong>=<em>alias</em></h4>
<p>Add a network-scoped alias for the pod, setting the alias for all
networks that the container joins. To set a name only for a specific
network, use the alias option as described under the
<strong>--network</strong> option. If the network has DNS enabled
(<code>podman network inspect -f {{.DNSEnabled}} &lt;name&gt;</code>),
these aliases can be used for name resolution on the given network. This
option can be specified multiple times. NOTE: When using CNI a pod only
has access to aliases on the first network that it joins. This
limitation does not exist with netavark/aardvark-dns.</p>
<h4 id="no-hostname"><strong>--no-hostname</strong></h4>
<p>Do not create the <em>/etc/hostname</em> file in the containers.</p>
<p>By default, Podman manages the <em>/etc/hostname</em> file, adding
the container's own hostname. When the <strong>--no-hostname</strong>
option is set, the image's <em>/etc/hostname</em> will be preserved
unmodified if it exists.</p>
<h4 id="no-hosts"><strong>--no-hosts</strong></h4>
<p>Do not modify the <code>/etc/hosts</code> file in the pod.</p>
<p>Podman assumes control over the pod's <code>/etc/hosts</code> file by
default and adds entries for the container's name (see
<strong>--name</strong> option) and hostname (see
<strong>--hostname</strong> option), the internal
<code>host.containers.internal</code> and
<code>host.docker.internal</code> hosts, as well as any hostname added
using the <strong>--add-host</strong> option. Refer to the
<strong>--add-host</strong> option for details. Passing
<strong>--no-hosts</strong> disables this, so that the image's
<code>/etc/hosts</code> file is kept unmodified. The same can be
achieved globally by setting <em>no_hosts=true</em> in
<code>containers.conf</code>.</p>
<p>This option conflicts with <strong>--add-host</strong>.</p>
<h4 id="pidpid"><strong>--pid</strong>=<em>pid</em></h4>
<p>Set the PID mode for the pod. The default is to create a private PID
namespace for the pod. Requires the PID namespace to be shared via
--share.</p>
<pre><code>host: use the host&#x2019;s PID namespace for the pod
ns: join the specified PID namespace
private: create a new namespace for the pod (default)</code></pre>
<h4
id="pod-id-filepath"><strong>--pod-id-file</strong>=<em>path</em></h4>
<p>Write the pod ID to the file.</p>
<h4
id="publish--piphostportcontainerportprotocol"><strong>--publish</strong>,
<strong>-p</strong>=<em>[[ip:][hostPort]:]containerPort[/protocol]</em></h4>
<p>Publish a container's port, or range of ports, within this pod to the
host.</p>
<p>Both <em>hostPort</em> and <em>containerPort</em> can be specified as
a range of ports. When specifying ranges for both, the number of
container ports in the range must match the number of host ports in the
range.</p>
<p>If host IP is set to 0.0.0.0 or not set at all, the port is bound on
all IPs on the host.</p>
<p>By default, Podman publishes TCP ports. To publish a UDP port
instead, give <code>udp</code> as protocol. To publish both TCP and UDP
ports, set <code>--publish</code> twice, with <code>tcp</code>, and
<code>udp</code> as protocols respectively. Rootful containers can also
publish ports using the <code>sctp</code> protocol.</p>
<p>Host port does not have to be specified (e.g.
<code>podman run -p 127.0.0.1::80</code>). If it is not, the container
port is randomly assigned a port on the host.</p>
<p>Use <strong>podman port</strong> to see the actual mapping:
<code>podman port $CONTAINER $CONTAINERPORT</code>.</p>
<p>Note that the network drivers <code>macvlan</code> and
<code>ipvlan</code> do not support port forwarding, therefore this
option will have no effect on such networks.</p>
<p><strong>Note:</strong> You must not publish ports of containers in
the pod individually, but only by the pod itself.</p>
<p><strong>Note:</strong> This cannot be modified once the pod is
created.</p>
<h4 id="replace"><strong>--replace</strong></h4>
<p>If another pod with the same name already exists, replace and remove
it. The default is <strong>false</strong>.</p>
<h4 id="restartpolicy"><strong>--restart</strong>=<em>policy</em></h4>
<p>Restart policy to follow when containers exit. Restart policy does
not take effect if a container is stopped via the <strong>podman
kill</strong> or <strong>podman stop</strong> commands.</p>
<p>Valid <em>policy</em> values are:</p>
<ul>
<li><code>no</code> : Do not restart containers on exit</li>
<li><code>never</code> : Synonym for <strong>no</strong>; do not restart
containers on exit</li>
<li><code>on-failure[:max_retries]</code> : Restart containers when they
exit with a non-zero exit code, retrying indefinitely or until the
optional <em>max_retries</em> count is hit</li>
<li><code>always</code> : Restart containers when they exit, regardless
of status, retrying indefinitely</li>
<li><code>unless-stopped</code> : Identical to
<strong>always</strong></li>
</ul>
<p>Podman provides a systemd unit file, podman-restart.service, which
restarts containers after a system reboot.</p>
<p>When running containers in systemd services, use the restart
functionality provided by systemd. In other words, do not use this
option in a container unit, instead set the <code>Restart=</code>
systemd directive in the <code>[Service]</code> section. See
<strong>podman-systemd.unit</strong>(5) and
<strong>systemd.service</strong>(5).</p>
<p>Default restart policy for all the containers in a pod.</p>
<h4
id="security-optoption"><strong>--security-opt</strong>=<em>option</em></h4>
<p>Security Options</p>
<ul>
<li><p><strong>apparmor=unconfined</strong> : Turn off apparmor
confinement for the pod</p></li>
<li><p><strong>apparmor</strong>=<em>alternate-profile</em> : Set the
apparmor confinement profile for the pod</p></li>
<li><p><strong>label=user:</strong>_USER_: Set the label user for the
pod processes</p></li>
<li><p><strong>label=role:</strong>_ROLE_: Set the label role for the
pod processes</p></li>
<li><p><strong>label=type:</strong>_TYPE_: Set the label process type
for the pod processes</p></li>
<li><p><strong>label=level:</strong>_LEVEL_: Set the label level for the
pod processes</p></li>
<li><p><strong>label=filetype:</strong>_TYPE_: Set the label file type
for the pod files</p></li>
<li><p><strong>label=disable</strong>: Turn off label separation for the
pod</p></li>
</ul>
<p>Note: Labeling can be disabled for all pods/containers by setting
label=false in the <strong>containers.conf</strong>
(<code>/etc/containers/containers.conf</code> or
<code>$HOME/.config/containers/containers.conf</code>) file.</p>
<ul>
<li><p><strong>label=nested</strong>: Allows SELinux modifications
within the container. Containers are allowed to modify SELinux labels on
files and processes, as long as SELinux policy allows. Without
<strong>nested</strong>, containers view SELinux as disabled, even when
it is enabled on the host. Containers are prevented from setting any
labels.</p></li>
<li><p><strong>mask</strong>=<em>/path/1:/path/2</em>: The paths to mask
separated by a colon. A masked path cannot be accessed inside the
containers within the pod.</p></li>
<li><p><strong>no-new-privileges</strong>: Disable container processes
from gaining additional privileges through the <code>execve(2)</code>
system call (e.g. via setuid or setgid bits, or via file capabilities).
Programs that rely on setuid/setgid bits set on their executable to
change user id or group id are no longer able to do so, and any file
capabilities added to the executable (e.g. via <code>setcap</code>) are
not added to the permitted capability set. For more details, see:
https://docs.kernel.org/userspace-api/no_new_privs.html.</p></li>
<li><p><strong>seccomp=unconfined</strong>: Turn off seccomp confinement
for the pod.</p></li>
<li><p><strong>seccomp=profile.json</strong>: JSON file to be used as a
seccomp filter. Note that the <code>io.podman.annotations.seccomp</code>
annotation is set with the specified value as shown in
<code>podman inspect</code>.</p></li>
<li><p><strong>proc-opts</strong>=<em>OPTIONS</em> : Comma-separated
list of options to use for the /proc mount. More details for the
possible mount options are specified in the <strong>proc(5)</strong> man
page.</p></li>
<li><p><strong>unmask</strong>=<em>ALL</em> or <em>/path/1:/path/2</em>,
or shell expanded paths (/proc/*): Paths to unmask separated by a colon.
If set to <strong>ALL</strong>, it unmasks all the paths that are masked
or made read-only by default. The default masked paths are
<strong>/proc/acpi, /proc/kcore, /proc/keys, /proc/latency_stats,
/proc/sched_debug, /proc/scsi, /proc/timer_list, /proc/timer_stats,
/sys/firmware, and /sys/fs/selinux</strong>,
<strong>/sys/devices/virtual/powercap</strong>. The default paths that
are read-only are <strong>/proc/asound</strong>,
<strong>/proc/bus</strong>, <strong>/proc/fs</strong>,
<strong>/proc/irq</strong>, <strong>/proc/sys</strong>,
<strong>/proc/sysrq-trigger</strong>,
<strong>/sys/fs/cgroup</strong>.</p></li>
</ul>
<p>Note: Labeling can be disabled for all containers by setting
<strong>label=false</strong> in the <strong>containers.conf</strong>(5)
file.</p>
<h4 id="sharenamespace"><strong>--share</strong>=<em>namespace</em></h4>
<p>A comma-separated list of kernel namespaces to share. If none or ""
is specified, no namespaces are shared, and the infra container is not
created unless explicitly specified via <strong>--infra=true</strong>.
The namespaces to choose from are cgroup, ipc, net, pid, uts. If the
option is prefixed with a "+", the namespace is appended to the default
list. Otherwise, it replaces the default list. Defaults match Kubernetes
default (ipc, net, uts)</p>
<h4 id="share-parent"><strong>--share-parent</strong></h4>
<p>This boolean determines whether or not all containers entering the
pod use the pod as their cgroup parent. The default value of this option
is true. Use the <strong>--share</strong> option to share the cgroup
namespace rather than a cgroup parent in a pod.</p>
<p>Note: This option conflicts with the <strong>--share=cgroup</strong>
option since that option sets the pod as the cgroup parent but enters
the container into the same cgroupNS as the infra container.</p>
<h4
id="shm-sizenumberunit"><strong>--shm-size</strong>=<em>number[unit]</em></h4>
<p>Size of <em>/dev/shm</em>. A <em>unit</em> can be <strong>b</strong>
(bytes), <strong>k</strong> (kibibytes), <strong>m</strong> (mebibytes),
or <strong>g</strong> (gibibytes). If the unit is omitted, the system
uses bytes. If the size is omitted, the default is <strong>64m</strong>.
When <em>size</em> is <strong>0</strong>, there is no limit on the
amount of memory used for IPC by the pod. This option conflicts with
<strong>--ipc=host</strong>.</p>
<h4
id="shm-size-systemdnumberunit"><strong>--shm-size-systemd</strong>=<em>number[unit]</em></h4>
<p>Size of systemd-specific tmpfs mounts such as /run, /run/lock,
/var/log/journal and /tmp. A <em>unit</em> can be <strong>b</strong>
(bytes), <strong>k</strong> (kibibytes), <strong>m</strong> (mebibytes),
or <strong>g</strong> (gibibytes). If the unit is omitted, the system
uses bytes. If the size is omitted, the default is <strong>64m</strong>.
When <em>size</em> is <strong>0</strong>, the usage is limited to 50% of
the host's available memory.</p>
<h4 id="subgidnamename"><strong>--subgidname</strong>=<em>name</em></h4>
<p>Run the container in a new user namespace using the map with
<em>name</em> in the <em>/etc/subgid</em> file. If running rootless, the
user needs to have the right to use the mapping. See
<strong>subgid</strong>(5). This flag conflicts with
<strong>--userns</strong> and <strong>--gidmap</strong>.</p>
<h4 id="subuidnamename"><strong>--subuidname</strong>=<em>name</em></h4>
<p>Run the container in a new user namespace using the map with
<em>name</em> in the <em>/etc/subuid</em> file. If running rootless, the
user needs to have the right to use the mapping. See
<strong>subuid</strong>(5). This flag conflicts with
<strong>--userns</strong> and <strong>--uidmap</strong>.</p>
<h4
id="sysctlnamevalue"><strong>--sysctl</strong>=<em>name=value</em></h4>
<p>Configure namespaced kernel parameters for all containers in the
pod.</p>
<p>For the IPC namespace, the following sysctls are allowed:</p>
<ul>
<li>kernel.msgmax</li>
<li>kernel.msgmnb</li>
<li>kernel.msgmni</li>
<li>kernel.sem</li>
<li>kernel.shmall</li>
<li>kernel.shmmax</li>
<li>kernel.shmmni</li>
<li>kernel.shm_rmid_forced</li>
<li>Sysctls beginning with fs.mqueue.*</li>
</ul>
<p>Note: if the ipc namespace is not shared within the pod, the above
sysctls are not allowed.</p>
<p>For the network namespace, only sysctls beginning with net.* are
allowed.</p>
<p>Note: if the network namespace is not shared within the pod, the
above sysctls are not allowed.</p>
<h4
id="uidmapcontainer_uidfrom_uidamount"><strong>--uidmap</strong>=<em>container_uid:from_uid:amount</em></h4>
<p>Run all containers in the pod in a new user namespace using the
supplied mapping. This option conflicts with the
<strong>--userns</strong> and <strong>--subuidname</strong> options.
This option provides a way to map host UIDs to container UIDs. It can be
passed several times to map different ranges.</p>
<h4 id="usernsmode"><strong>--userns</strong>=<em>mode</em></h4>
<p>Set the user namespace mode for all the containers in a pod. It
defaults to the <code>PODMAN_USERNS</code> environment variable. An
empty value ("") means user namespaces are disabled.</p>
<p>Rootless user --userns=Key mappings:</p>
<table>
<colgroup>
<col style="width: 21%" />
<col style="width: 32%" />
<col style="width: 45%" />
</colgroup>
<thead>
<tr class="header">
<th>Key</th>
<th>Host User</th>
<th>Container User</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>""</td>
<td><span
class="math inline"><em>U</em><em>I</em><em>D</em>|0(<em>D</em><em>e</em><em>f</em><em>a</em><em>u</em><em>l</em><em>t</em><em>U</em><em>s</em><em>e</em><em>r</em><em>a</em><em>c</em><em>c</em><em>o</em><em>u</em><em>n</em><em>t</em><em>m</em><em>a</em><em>p</em><em>p</em><em>e</em><em>d</em><em>t</em><em>o</em><em>r</em><em>o</em><em>o</em><em>t</em><em>u</em><em>s</em><em>e</em><em>r</em><em>i</em><em>n</em><em>c</em><em>o</em><em>n</em><em>t</em><em>a</em><em>i</em><em>n</em><em>e</em><em>r</em>.)<em>h</em><em>o</em><em>s</em><em>t</em>|</span>UID</td>
<td>0 (Default User account mapped to root user in container.)</td>
</tr>
<tr class="even">
<td>keep-id</td>
<td><span class="math inline"><em>U</em><em>I</em><em>D</em>|</span>UID
(Map user account to same UID within container.)</td>
<td></td>
</tr>
<tr class="odd">
<td>auto</td>
<td><span
class="math inline"><em>U</em><em>I</em><em>D</em>|<em>n</em><em>i</em><em>l</em>(<em>H</em><em>o</em><em>s</em><em>t</em><em>U</em><em>s</em><em>e</em><em>r</em><em>U</em><em>I</em><em>D</em><em>i</em><em>s</em><em>n</em><em>o</em><em>t</em><em>m</em><em>a</em><em>p</em><em>p</em><em>e</em><em>d</em><em>i</em><em>n</em><em>t</em><em>o</em><em>c</em><em>o</em><em>n</em><em>t</em><em>a</em><em>i</em><em>n</em><em>e</em><em>r</em>.)<em>n</em><em>o</em><em>m</em><em>a</em><em>p</em>|</span>UID</td>
<td>nil (Host User UID is not mapped into container.)</td>
</tr>
</tbody>
</table>
<p>Valid <em>mode</em> values are:</p>
<ul>
<li><p><em>auto[:<em><em>OPTIONS,...</em></em>]</em>: automatically
create a namespace. It is possible to specify these options to
<code>auto</code>:</p>
<ul>
<li><p><em>gidmapping=</em>_CONTAINER_GID:HOST_GID:SIZE_ to force a GID
mapping to be present in the user namespace.</p></li>
<li><p><em>size=</em>_SIZE_: to specify an explicit size for the
automatic user namespace. e.g. <code>--userns=auto:size=8192</code>. If
<code>size</code> is not specified, <code>auto</code> estimates the size
for the user namespace.</p></li>
<li><p><em>uidmapping=</em>_CONTAINER_UID:HOST_UID:SIZE_ to force a UID
mapping to be present in the user namespace.</p></li>
</ul></li>
<li><p><em>host</em>: run in the user namespace of the caller. The
processes running in the container have the same privileges on the host
as any other process launched by the calling user (default).</p></li>
<li><p><em>keep-id</em>: creates a user namespace where the current
rootless user's UID:GID are mapped to the same values in the container.
This option is not allowed for containers created by the root
user.</p></li>
<li><p><em>nomap</em>: creates a user namespace where the current
rootless user's UID:GID are not mapped into the container. This option
is not allowed for containers created by the root user.</p></li>
</ul>
<h4 id="utsmode"><strong>--uts</strong>=<em>mode</em></h4>
<p>Set the UTS namespace mode for the pod. The following values are
supported:</p>
<ul>
<li><strong>host</strong>: use the host's UTS namespace inside the
pod.</li>
<li><strong>private</strong>: create a new namespace for the pod
(default).</li>
<li><strong>ns:[path]</strong>: run the pod in the given existing UTS
namespace.</li>
</ul>
<h4
id="volume--vsource-volumehost-dircontainer-diroptions"><strong>--volume</strong>,
<strong>-v</strong>=<em>[[SOURCE-VOLUME|HOST-DIR:]CONTAINER-DIR[:OPTIONS]]</em></h4>
<p>Create a bind mount. If <code>-v /HOST-DIR:/CONTAINER-DIR</code> is
specified, Podman bind mounts <code>/HOST-DIR</code> from the host into
<code>/CONTAINER-DIR</code> in the Podman container. Similarly,
<code>-v SOURCE-VOLUME:/CONTAINER-DIR</code> mounts the named volume
from the host into the container. If no such named volume exists, Podman
creates one. If no source is given, the volume is created as an
anonymously named volume with a randomly generated name, and is removed
when the pod is removed via the <code>--rm</code> flag or the
<code>podman rm --volumes</code> command.</p>
<p>(Note when using the remote client, including Mac and Windows
(excluding WSL2) machines, the volumes are mounted from the remote
server, not necessarily the client machine.)</p>
<p>The <em>OPTIONS</em> is a comma-separated list and can be one or more
of:</p>
<ul>
<li><strong>rw</strong>|<strong>ro</strong></li>
<li><strong>z</strong>|<strong>Z</strong></li>
<li>[<strong>O</strong>]</li>
<li>[<strong>U</strong>]</li>
<li>[<strong>no</strong>]<strong>copy</strong></li>
<li>[<strong>no</strong>]<strong>dev</strong></li>
<li>[<strong>no</strong>]<strong>exec</strong></li>
<li>[<strong>no</strong>]<strong>suid</strong></li>
<li>[<strong>r</strong>]<strong>bind</strong></li>
<li>[<strong>r</strong>]<strong>shared</strong>|[<strong>r</strong>]<strong>slave</strong>|[<strong>r</strong>]<strong>private</strong>[<strong>r</strong>]<strong>unbindable</strong>
<sup><a href="#Footnote1">[1]</a></sup></li>
<li><strong>idmap</strong>[=<strong>options</strong>]</li>
</ul>
<p>The <code>CONTAINER-DIR</code> must be an absolute path such as
<code>/src/docs</code>. The volume is mounted into the container at this
directory.</p>
<p>If a volume source is specified, it must be a path on the host or the
name of a named volume. Host paths are allowed to be absolute or
relative; relative paths are resolved relative to the directory Podman
is run in. If the source does not exist, Podman returns an error. Users
must pre-create the source files or directories.</p>
<p>Any source that does not begin with a <code>.</code> or
<code>/</code> is treated as the name of a named volume. If a volume
with that name does not exist, it is created. Volumes created with names
are not anonymous, and they are not removed by the <code>--rm</code>
option and the <code>podman rm --volumes</code> command.</p>
<p>Specify multiple <strong>-v</strong> options to mount one or more
volumes into a pod.</p>
<p><code>Write Protected Volume Mounts</code></p>
<p>Add <strong>:ro</strong> or <strong>:rw</strong> option to mount a
volume in read-only or read-write mode, respectively. By default, the
volumes are mounted read-write. See examples.</p>
<p><code>Chowning Volume Mounts</code></p>
<p>When a named volume is first mounted to a container, Podman
automatically adjusts the ownership of the volume's mount point during
container initialization. This chown operation occurs under the
following conditions:</p>
<ul>
<li>The volume was not used yet (has <code>NeedsChown</code> set to
true)</li>
<li>The volume is empty or has not been copied up yet</li>
<li>The volume is not managed by an external volume driver</li>
<li>The volume driver is not "image"</li>
</ul>
<p>For volumes with idmapped mounts (using the <code>idmap</code>
option), the ownership change takes into account the container's user
namespace mappings, but the idmapped volume retains proper UID/GID
mapping. For volumes without idmapping, the mount point is chowned to
match the container's process user and group, mapped to the host user
namespace if user namespace remapping is enabled.</p>
<p>If a pod is created in a new user namespace, the UID and GID in the
container may correspond to another UID and GID on the host.</p>
<p>The <code>:U</code> suffix tells Podman to use the correct host UID
and GID based on the UID and GID within the pod, to change recursively
the owner and group of the source volume. Chowning walks the file system
under the volume and changes the UID/GID on each file. If the volume has
thousands of inodes, this process takes a long time, delaying the start
of the pod.</p>
<p><strong>Warning</strong> use with caution since this modifies the
host filesystem.</p>
<p><code>Labeling Volume Mounts</code></p>
<p>Labeling systems like SELinux require that proper labels are placed
on volume content mounted into a pod. Without a label, the security
system might prevent the processes running inside the pod from using the
content. By default, Podman does not change the labels set by the
OS.</p>
<p>To change a label in the pod context, add either of two suffixes
<strong>:z</strong> or <strong>:Z</strong> to the volume mount. These
suffixes tell Podman to relabel file objects on the shared volumes. The
<strong>z</strong> option tells Podman that two or more pods share the
volume content. As a result, Podman labels the content with a shared
content label. Shared volume labels allow all containers to read/write
content. The <strong>Z</strong> option tells Podman to label the content
with a private unshared label. Only the current pod can use a private
volume.</p>
<p>Note: all containers within a <code>pod</code> share the same SELinux
label. This means all containers within said pod can read/write volumes
shared into the container created with the <code>:Z</code> on any one of
the containers. Relabeling walks the file system under the volume and
changes the label on each file; if the volume has thousands of inodes,
this process takes a long time, delaying the start of the pod. If the
volume was previously relabeled with the <code>z</code> option, Podman
is optimized to not relabel a second time. If files are moved into the
volume, then the labels can be manually changed with the
<code>chcon -Rt container_file_t PATH</code> command.</p>
<p>Note: Do not relabel system files and directories. Relabeling system
content might cause other confined services on the machine to fail. For
these types of containers we recommend disabling SELinux separation. The
option <strong>--security-opt label=disable</strong> disables SELinux
separation for the pod. For example if a user wanted to volume mount
their entire home directory into a pod, they need to disable SELinux
separation.</p>
<pre><code>$ podman pod create --security-opt label=disable -v $HOME:/home/user fedora touch /home/user/file</code></pre>
<p><code>Overlay Volume Mounts</code></p>
<p>The <code>:O</code> flag tells Podman to mount the directory from the
host as a temporary storage using the <code>overlay file system</code>.
The pod processes can modify content within the mountpoint which is
stored in the container storage in a separate directory. In overlay
terms, the source directory is the lower, and the container storage
directory is the upper. Modifications to the mount point are destroyed
when the pod finishes executing, similar to a tmpfs mount point being
unmounted.</p>
<p>For advanced users, the <strong>overlay</strong> option also supports
custom non-volatile <strong>upperdir</strong> and
<strong>workdir</strong> for the overlay mount. Custom
<strong>upperdir</strong> and <strong>workdir</strong> can be fully
managed by the users themselves, and Podman does not remove it on
lifecycle completion. Example
<strong>:O,upperdir=/some/upper,workdir=/some/work</strong></p>
<p>Subsequent executions of the container sees the original source
directory content, any changes from previous pod executions no longer
exist.</p>
<p>One use case of the overlay mount is sharing the package cache from
the host into the container to allow speeding up builds.</p>
<p>Note: The <code>O</code> flag conflicts with other options listed
above.</p>
<p>Content mounted into the container is labeled with the private label.
On SELinux systems, labels in the source directory must be readable by
the pod infra container label. Usually containers can read/execute
<code>container_share_t</code> and can read/write
<code>container_file_t</code>. If unable to change the labels on a
source volume, SELinux container separation must be disabled for the pod
or infra container to work.</p>
<p>Do not modify the source directory mounted into the pod with an
overlay mount, it can cause unexpected failures. Only modify the
directory after the container finishes running.</p>
<p><code>Mounts propagation</code></p>
<p>By default, bind-mounted volumes are <code>private</code>. That means
any mounts done inside the pod are not visible on the host and vice
versa. One can change this behavior by specifying a volume mount
propagation property. When a volume is <code>shared</code>, mounts done
under that volume inside the pod are visible on host and vice versa.
Making a volume <strong>slave</strong><sup><a
href="#Footnote1">[1]</a></sup> enables only one-way mount propagation:
mounts done on the host under that volume are visible inside the
container but not the other way around.</p>
<p>To control mount propagation property of a volume one can use the
[<strong>r</strong>]<strong>shared</strong>,
[<strong>r</strong>]<strong>slave</strong>,
[<strong>r</strong>]<strong>private</strong> or the
[<strong>r</strong>]<strong>unbindable</strong> propagation flag.
Propagation property can be specified only for bind mounted volumes and
not for internal volumes or named volumes. For mount propagation to work
the source mount point (the mount point where source dir is mounted on)
has to have the right propagation properties. For shared volumes, the
source mount point has to be shared. And for slave volumes, the source
mount point has to be either shared or slave. <sup><a
href="#Footnote1">[1]</a></sup></p>
<p>To recursively mount a volume and all of its submounts into a pod,
use the <strong>rbind</strong> option. By default the bind option is
used, and submounts of the source directory is not mounted into the
pod.</p>
<p>Mounting the volume with a <strong>copy</strong> option tells podman
to copy content from the underlying destination directory onto newly
created internal volumes. The <strong>copy</strong> only happens on the
initial creation of the volume. Content is not copied up when the volume
is subsequently used on different containers. The <strong>copy</strong>
option is ignored on bind mounts and has no effect.</p>
<p>Mounting volumes with the <strong>nosuid</strong> options means that
SUID executables on the volume can not be used by applications to change
their privilege. By default volumes are mounted with
<strong>nosuid</strong>.</p>
<p>Mounting the volume with the <strong>noexec</strong> option means
that no executables on the volume can be executed within the pod.</p>
<p>Mounting the volume with the <strong>nodev</strong> option means that
no devices on the volume can be used by processes within the pod. By
default volumes are mounted with <strong>nodev</strong>.</p>
<p>If the <em>HOST-DIR</em> is a mount point, then <strong>dev</strong>,
<strong>suid</strong>, and <strong>exec</strong> options are ignored by
the kernel.</p>
<p>Use <strong>df HOST-DIR</strong> to figure out the source mount, then
use <strong>findmnt -o TARGET,PROPAGATION
<em>source-mount-dir</em></strong> to figure out propagation properties
of source mount. If <strong>findmnt</strong>(1) utility is not
available, then one can look at the mount entry for the source mount
point in <em>/proc/self/mountinfo</em>. Look at the "optional fields"
and see if any propagation properties are specified. In there,
<strong>shared:N</strong> means the mount is shared,
<strong>master:N</strong> means mount is slave, and if nothing is there,
the mount is private. <sup><a href="#Footnote1">[1]</a></sup></p>
<p>To change propagation properties of a mount point, use
<strong>mount</strong>(8) command. For example, if one wants to bind
mount source directory <em>/foo</em>, one can do <strong>mount --bind
/foo /foo</strong> and <strong>mount --make-private --make-shared
/foo</strong>. This converts /foo into a shared mount point.
Alternatively, one can directly change propagation properties of source
mount. Say <em>/</em> is source mount for <em>/foo</em>, then use
<strong>mount --make-shared /</strong> to convert <em>/</em> into a
shared mount.</p>
<p>Note: if the user only has access rights via a group, accessing the
volume from inside a rootless pod fails.</p>
<p><code>Idmapped mount</code></p>
<p>If <code>idmap</code> is specified, create an idmapped mount to the
target user namespace in the container. The idmap option supports a
custom mapping that can be different than the user namespace used by the
container. The mapping can be specified after the idmap option like:
<code>idmap=uids=0-1-10#10-11-10;gids=0-100-10</code>. For each triplet,
the first value is the start of the backing file system IDs that are
mapped to the second value on the host. The length of this mapping is
given in the third value. Multiple ranges are separated with #.</p>
<h4
id="volumes-fromcontaineroptions"><strong>--volumes-from</strong>=<em>CONTAINER[:OPTIONS]</em></h4>
<p>Mount volumes from the specified container(s). Used to share volumes
between containers and pods. The <em>options</em> is a comma-separated
list with the following available elements:</p>
<ul>
<li><strong>rw</strong>|<strong>ro</strong></li>
<li><strong>z</strong></li>
</ul>
<p>Mounts already mounted volumes from a source container onto another
pod. <em>CONTAINER</em> may be a name or ID. To share a volume, use the
--volumes-from option when running the target container. Volumes can be
shared even if the source container is not running.</p>
<p>By default, Podman mounts the volumes in the same mode (read-write or
read-only) as it is mounted in the source container. This can be changed
by adding a <code>ro</code> or <code>rw</code> <em>option</em>.</p>
<p>Labeling systems like SELinux require that proper labels are placed
on volume content mounted into a pod. Without a label, the security
system might prevent the processes running inside the container from
using the content. By default, Podman does not change the labels set by
the OS.</p>
<p>To change a label in the pod context, add <code>z</code> to the
volume mount. This suffix tells Podman to relabel file objects on the
shared volumes. The <code>z</code> option tells Podman that two entities
share the volume content. As a result, Podman labels the content with a
shared content label. Shared volume labels allow all containers to
read/write content.</p>
<p>If the location of the volume from the source container overlaps with
data residing on a target pod, then the volume hides that data on the
target.</p>
<h2 id="examples">EXAMPLES</h2>
<p>Create a named pod.</p>
<pre><code>$ podman pod create --name test</code></pre>
<p>Create a named pod.</p>
<pre><code>$ podman pod create mypod</code></pre>
<p>Create a pod without an infra container.</p>
<pre><code>$ podman pod create --infra=false</code></pre>
<p>Create a named pod with infra container command to run.</p>
<pre><code>$ podman pod create --infra-command /top toppod</code></pre>
<p>Create a pod with published ports on the host.</p>
<pre><code>$ podman pod create --publish 8443:443</code></pre>
<p>Create a pod with the specified network configuration.</p>
<pre><code>$ podman pod create --network slirp4netns:outbound_addr=127.0.0.1,allow_host_loopback=true</code></pre>
<p>Create a pod with the specified network.</p>
<pre><code>$ podman pod create --network pasta</code></pre>
<p>Create a pod on two networks.</p>
<pre><code>$ podman pod create --network net1:ip=10.89.1.5 --network net2:ip=10.89.10.10</code></pre>
<h2 id="see-also">SEE ALSO</h2>
<p><strong><a href="podman.html">podman(1)</a></strong>, <strong><a
href="podman-pod.html">podman-pod(1)</a></strong>, <strong><a
href="podman-kube-play.html">podman-kube-play(1)</a></strong>,
<strong>containers.conf(1)</strong>, <strong><a
href="https://man7.org/linux/man-pages/man7/cgroups.7.html">cgroups(7)</a></strong></p>
<h3 id="troubleshooting">Troubleshooting</h3>
<p>See <a
href="https://github.com/containers/podman/blob/main/troubleshooting.md">podman-troubleshooting(7)</a>
for solutions to common issues.</p>
<h2 id="history">HISTORY</h2>
<p>July 2018, Originally compiled by Peter Hunt <a
href="mailto:pehunt@redhat.com" class="email">pehunt@redhat.com</a></p>
<h2 id="footnotes">FOOTNOTES</h2>
<p><a name="Footnote1">1</a>: The Podman project is committed to
inclusivity, a core value of open source. The <code>master</code> and
<code>slave</code> mount propagation terminology used here is
problematic and divisive, and needs to be changed. However, these terms
are currently used within the Linux kernel and must be used as-is at
this time. When the kernel maintainers rectify this usage, Podman will
follow suit immediately.</p>
</body>
</html>
